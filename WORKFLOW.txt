Vakilsearch Platform — Project Workflow

Overview
--------
This document describes the end-to-end workflow to develop, run, test, and deploy the Vakilsearch full-stack platform (React frontend + Java/Spring Boot microservices + MySQL). It covers local development, Docker, database initialization, testing, CI/CD, and recommended integrations.

1. Prerequisites
----------------
- Node.js >= 18 and npm
- Java 17 and Maven
- Docker & Docker Compose
- MySQL client (optional)
- Git

2. Repository layout
--------------------
- frontend/                # React + Vite + Tailwind frontend
- services/                # Spring Boot microservices (crm-service, onboarding-service, ...)
- libraries/               # Shared Java artifacts (DTOs, utilities)
- deployments/             # docker-compose, k8s manifests, DB init
- WORKFLOW.txt             # This file

3. Environment variables
------------------------
Create a .env file (or export variables) for local development. Example variables used by docker-compose and services:
- MYSQL_ROOT_PASSWORD=rootpass
- MYSQL_DATABASE=vakilsearch
- MYSQL_USER=vakil
- MYSQL_PASSWORD=vakilpass
- SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/vakilsearch
- SPRING_DATASOURCE_USERNAME=vakil
- SPRING_DATASOURCE_PASSWORD=vakilpass

Place sensitive values in your CI/CD secrets store (GitHub Secrets, GitLab CI variables, etc.)

4. Local development (fast path)
--------------------------------
A. Start DB with Docker Compose (in repo root):
  docker-compose up -d mysql
  # Confirm DB ready: docker logs <container> or mysql client

B. Start backend microservice (crm-service example):
  cd services/crm-service
  ./mvnw spring-boot:run
  # or: mvn spring-boot:run
  # Service default port: 8081

C. Start frontend (dev):
  cd frontend
  npm install
  npm run dev
  # Dev server typically at http://localhost:5173

D. Verify endpoints:
  - Frontend: http://localhost:5173
  - CRM API: http://localhost:8081/api/leads

5. Database migrations and initialization
----------------------------------------
- The scaffold uses JPA with spring.jpa.hibernate.ddl-auto=update for development convenience.
- For production, use a proper migration tool (Flyway or Liquibase). Recommended:
  - Add Flyway dependency to each service
  - Place SQL migrations in src/main/resources/db/migration

6. Running with Docker (full stack)
----------------------------------
A. Build images (optional locally):
  # Frontend
  docker build -t vakilsearch-frontend:local ./frontend
  # CRM service
  docker build -t vakilsearch-crm:local ./services/crm-service

B. Start all services with docker-compose (root):
  docker-compose up --build

C. Health checks:
  - CRM: http://localhost:8081/actuator/health (if actuator added)
  - Frontend: http://localhost:80 (if served via nginx)

7. Logs & troubleshooting
-------------------------
- Docker: docker-compose logs -f
- Spring: check application.yml logging and console errors
- Frontend: check browser console and terminal where vite runs
- Typical issues:
  - DB connection errors: verify credentials and that MySQL is reachable from containers
  - CORS: add appropriate CORS config in Spring Boot for local dev (allow localhost:5173)

8. Testing
----------
- Frontend:
  - Unit tests (Jest or React Testing Library) — add test scripts as needed
  - Linting & formatting: ESLint + Prettier
- Backend:
  - Run unit tests with Maven: mvn test
  - Add integration tests using Testcontainers to spin up a MySQL container for CI

9. CI/CD Recommendations
-------------------------
- Use GitHub Actions, GitLab CI, or similar. Typical pipeline stages:
  1. install dependencies
  2. run linters and unit tests
  3. build artifacts (frontend build, maven package)
  4. run integration tests (Testcontainers)
  5. build and push Docker images to registry
  6. deploy to staging/production (k8s or docker-compose on server)

- Keep secrets in CI: DB credentials, registry credentials, cloud provider keys.

10. Production deployment
-------------------------
Options:
- Kubernetes: create Deployment, Service, Ingress, ConfigMap, and Secret manifests. Use Horizontal Pod Autoscaler for scale.
- Docker Compose on VM: suitable for small deployments.
- Managed platforms: deploy frontend to static hosts (Netlify, Vercel) and services to GKE/EKS/managed VM.

Monitoring & Observability:
- Add Prometheus metrics and Grafana dashboards
- Use Sentry for error reporting
- Centralized logging (ELK/EFK)

11. Security & Compliance
-------------------------
- Secrets: do NOT commit to repo. Use vault/secret manager.
- RBAC and authentication: integrate OAuth2 or JWT-based auth module in security-module
- Data encryption: enable TLS for external communication and encrypt data at rest if required by compliance
- Audit logs: centralized audit trail for important actions

12. Scaling & architecture notes
--------------------------------
- Microservices are independent; scale per-service based on load.
- Consider a gateway (API Gateway) in front of services for routing, auth and rate-limiting.
- Use message broker (RabbitMQ/Kafka) for async execution (long-running gov portal polling or document processing)

13. Developer workflow (day-to-day)
----------------------------------
- Branching: feature branches per ticket, PRs to main
- Local run: start DB (docker-compose up -d mysql), run backend and frontend locally
- Tests: run unit tests before push; run integration tests on PR CI
- Code reviews: require 1-2 reviewers per PR, add CI status checks

14. Extending the scaffold
--------------------------
- Add more services under services/ (case-management, sales-payment, execution-*). Each service should have:
  - pom.xml
  - src/main/java entrypoint
  - application.yml with externalized configs
  - Dockerfile
- Add libraries/shared-models for DTOs used across services (publish to internal Maven repo or include as a module)

15. Troubleshooting common errors
---------------------------------
- "Communications link failure" from Spring Boot: check that service hostname matches docker-compose service name (mysql) and that the DB container finished init.
- Port already in use: change service ports in docker-compose or stop conflicting processes.
- Slow startup: check DB initialization scripts under deployments/mysql-init and container logs.

16. Recommended MCP Integrations
--------------------------------
These integrations can help while building and operating the platform. Use the Builder UI to connect or manage them.
- Supabase — database & auth (rapid prototyping; use instead of MySQL for quick PoCs). Connect via: [Connect to Supabase](#open-mcp-popover)
- Neon — serverless Postgres alternative. Connect via: [Connect to Neon](#open-mcp-popover)
- Netlify — frontend hosting and CI. Connect via: [Connect to Netlify](#open-mcp-popover)
- Zapier — automation & workflows. Connect via: [Connect to Zapier](#open-mcp-popover)
- Figma — design import (use Builder.io Figma plugin). Use "Get Plugin" in MCP servers or: https://www.figma.com/community/plugin/747985167520967365/builder-io-ai-powered-figma-to-code-react-vue-tailwind-more
- Builder.io — CMS & content management. Connect via: [Connect to Builder.io](#open-mcp-popover)
- Linear — issue tracking. Connect via: [Connect to Linear](#open-mcp-popover)
- Notion — documentation and knowledge management. Connect via: [Connect to Notion](#open-mcp-popover)
- Sentry — error monitoring and debugging. Connect via: [Connect to Sentry](#open-mcp-popover)
- Context7 — documentation lookup for libraries and frameworks
- Semgrep — static application security testing (SAST)
- Prisma Postgres — ORM option for Node services (if you introduce Node-based microservices)

Note: When working directly with databases from the UI or other tooling you may prefer Supabase/Neon, but the scaffold uses MySQL per your requirement.

17. Next steps (suggested immediate actions)
-------------------------------------------
1. Confirm which microservices you want implemented first (crm, onboarding, case-management, payments)
2. Add Flyway to services for migrations
3. Add CI pipeline template (GitHub Actions) for build/test/deploy
4. Add automated integration tests using Testcontainers

18. Contacts & references
-------------------------
- Repo README contains quick commands. See individual service README files for more details.

---
End of workflow
